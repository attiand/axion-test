plugins {
    id 'base'
    id 'pl.allegro.tech.build.axion-release' version '1.13.14'
}

import org.eclipse.jgit.api.Git
import org.eclipse.jgit.treewalk.CanonicalTreeParser
import org.eclipse.jgit.lib.*

scmVersion {
    branchVersionCreator = [
        'rel_.*': 'simple',
        'patch_.*': 'simple',
        '.*': 'versionWithBranch'
    ]
    useHighestVersion = true
    ignoreUncommittedChanges = false
    tag {
        prefix = ''
    }

    hooks {
        post {context -> file("${buildDir}/upgrade.txt").text = databaseUpgrade(context.previousVersion, context.currentVersion)}
    }
}


String databaseUpgrade(def previousVersion, def releaseVersion) {
    Git git = Git.open(file('.'))
    Repository repository = git.getRepository()
    
    ObjectId p = repository.resolve(previousVersion + '^{tree}')
    ObjectId c = repository.resolve(releaseVersion + '^{tree}')

    logger.debug('analysing diff between tree: {} and {}', p, c)

    ObjectReader reader = repository.newObjectReader();
    CanonicalTreeParser pTreeIter = new CanonicalTreeParser();
    pTreeIter.reset(reader, p);
    CanonicalTreeParser cTreeIter = new CanonicalTreeParser();
    cTreeIter.reset(reader, c);

    def diffs = git.diff()
            .setNewTree(cTreeIter)
            .setOldTree(pTreeIter)
            .call();

    def upgrades = diffs.findResults { d ->
        d.getNewPath().find(~/\/migration\/(V[^\/]+)/) { _, v ->
            v
        }
    }

    logger.debug('upgrades: {}', upgrades)

    def version = upgrades.unique()

    if(version.size() == 1) {
        return version.first()
    }
    else {
        logger.error('could not determine upgrade version: {}', version)
        return []
    }
}